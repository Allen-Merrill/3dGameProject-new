<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense Shooting Prototype</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; }
</style>

<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r146/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r146/examples/js/controls/OrbitControls.js"></script>

</head>
<body>
<div id="ui">ðŸ’Ž Gold: <span id="gold">100</span> | ðŸ§Ÿ Wave: <span id="wave">1</span></div>

<script>
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(25, 40, 60);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(25,0,25);
controls.update();

const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(20, 40, 20);
scene.add(dirLight);

const GRID_SIZE = 10;
const TILE_SIZE = 5;

// 0 = buildable, 1 = path
const grid = [
  [0,0,0,0,0,0,0,0,0,0],
  [0,1,1,1,0,0,0,0,0,0],
  [0,0,0,1,0,0,1,1,1,0],
  [0,0,0,1,0,0,0,0,1,0],
  [0,0,0,1,1,1,1,0,1,0],
  [0,0,0,0,0,0,1,0,1,0],
  [0,0,0,0,1,1,1,0,1,0],
  [0,0,0,0,1,0,0,0,1,0],
  [0,0,0,0,1,1,1,1,1,0],
  [0,0,0,0,0,0,0,0,0,0]
];

const tiles = [];
const pathTiles = [];

for(let y=0;y<GRID_SIZE;y++){
  for(let x=0;x<GRID_SIZE;x++){
    const val = grid[y][x];
    const color = val === 1 ? 0xffd700 : 0x2e8b57;
    const geo = new THREE.BoxGeometry(TILE_SIZE,0.5,TILE_SIZE);
    const mat = new THREE.MeshLambertMaterial({color});
    const mesh = new THREE.Mesh(geo,mat);
    mesh.position.set(x*TILE_SIZE+TILE_SIZE/2,0.25,y*TILE_SIZE+TILE_SIZE/2);
    scene.add(mesh);
    tiles.push(mesh);
    if(val===1) pathTiles.push(mesh);
  }
}

const pathPositions = [
  {x:1,y:1},{x:2,y:1},{x:3,y:1},{x:3,y:2},{x:3,y:3},{x:3,y:4},{x:4,y:4},
  {x:5,y:4},{x:6,y:4},{x:6,y:5},{x:6,y:6},{x:5,y:6},{x:4,y:6},{x:4,y:7},
  {x:4,y:8},{x:5,y:8},{x:6,y:8},{x:7,y:8}
].map(p=>new THREE.Vector3(p.x*TILE_SIZE+TILE_SIZE/2,0.5,p.y*TILE_SIZE+TILE_SIZE/2));

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const towers = [];
const placedTowers = new Set();
const enemies = [];
const projectiles = [];

window.addEventListener('click',(event)=>{
  mouse.x = (event.clientX / window.innerWidth)*2 - 1;
  mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(tiles);
  if(intersects.length>0){
    const tile = intersects[0].object;
    if(tile.material.color.getHex()===0x2e8b57){
      const key = tile.position.x + "," + tile.position.z;
      if(!placedTowers.has(key)){
        const towerGeo = new THREE.CylinderGeometry(1.5,1.5,4,12);
        const towerMat = new THREE.MeshLambertMaterial({color:0x0080ff});
        const tower = new THREE.Mesh(towerGeo,towerMat);
        tower.position.set(tile.position.x,2,tile.position.z);
        scene.add(tower);
        towers.push({mesh:tower, cooldown:0});
        placedTowers.add(key);
      }
    }
  }
});

// spawn an enemy every few seconds
let enemySpawnTimer = 0;
function spawnEnemy(){
  const geo = new THREE.SphereGeometry(1,16,16);
  const mat = new THREE.MeshLambertMaterial({color:0xff0000});
  const enemy = new THREE.Mesh(geo,mat);
  enemy.pathIndex = 0;
  enemy.progress = 0;
  enemy.position.copy(pathPositions[0]);
  enemy.hp = 100;
  scene.add(enemy);
  enemies.push(enemy);
}

// spawn projectile from tower to target
function spawnProjectile(from, to){
  const geo = new THREE.SphereGeometry(0.5,8,8);
  const mat = new THREE.MeshBasicMaterial({color:0xffffff});
  const proj = new THREE.Mesh(geo,mat);
  proj.position.copy(from.position);
  proj.target = to;
  scene.add(proj);
  projectiles.push(proj);
}

function updateEnemies(delta){
  enemies.forEach((enemy, i)=>{
    const speed = 4 * delta;
    enemy.progress += speed / TILE_SIZE;
    if(enemy.progress >= 1){
      enemy.progress = 0;
      enemy.pathIndex++;
      if(enemy.pathIndex >= pathPositions.length-1){
        scene.remove(enemy);
        enemies.splice(i,1);
        return;
      }
    }
    const start = pathPositions[enemy.pathIndex];
    const end = pathPositions[enemy.pathIndex+1];
    enemy.position.lerpVectors(start,end,enemy.progress);
  });
}

function updateTowers(delta){
  towers.forEach(tower=>{
    tower.cooldown -= delta;
    if(tower.cooldown <= 0){
      // find nearest enemy in range
      const range = 15;
      let target = null;
      let minDist = range;
      enemies.forEach(e=>{
        const dist = tower.mesh.position.distanceTo(e.position);
        if(dist < minDist){
          target = e;
          minDist = dist;
        }
      });
      if(target){
        spawnProjectile(tower.mesh, target);
        tower.cooldown = 1; // 1 second cooldown
      }
    }
  });
}

function updateProjectiles(delta){
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    if(!p.target || !enemies.includes(p.target)){
      scene.remove(p);
      projectiles.splice(i,1);
      continue;
    }
    const dir = new THREE.Vector3().subVectors(p.target.position, p.position);
    const dist = dir.length();
    dir.normalize();
    const speed = 25 * delta;
    p.position.addScaledVector(dir, speed);
    if(dist < 1){
      // hit target
      p.target.hp -= 25;
      if(p.target.hp <= 0){
        scene.remove(p.target);
        enemies.splice(enemies.indexOf(p.target),1);
      }
      scene.remove(p);
      projectiles.splice(i,1);
    }
  }
}

let lastTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const delta = (now - lastTime)/1000;
  lastTime = now;

  enemySpawnTimer += delta;
  if(enemySpawnTimer > 3){
    spawnEnemy();
    enemySpawnTimer = 0;
  }

  updateEnemies(delta);
  updateTowers(delta);
  updateProjectiles(delta);

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
