<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Maze Explorer - demo</title>
  <style>
    html,body { height:100%; margin:0; background:#111; color:#eee; font-family:system-ui,Segoe UI,Roboto,Arial; }
    #ui {
      position: absolute;
      left: 16px;
      top: 16px;
      z-index: 10;
      display:flex;
      gap:8px;
      align-items:center;
    }
    button {
      background:#1f6feb;
      color:white;
      border: none;
      padding: .6rem .9rem;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 4px 10px rgba(0,0,0,.6);
    }
    button:disabled { background: #444; cursor:not-allowed; opacity:.8; }
    #hint { font-size: .9rem; opacity:.9; margin-left:6px; color:#ddd; }
    #canvas-container { width:100%; height:100%; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }
    /* small credit */
    #credit { position:absolute; right:12px; bottom:12px; font-size:12px; color:#bbb; opacity:.9; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start Game</button>
    <button id="resetBtn" disabled>Reset</button>
    <div id="hint">Click <strong>Start Game</strong> to initialize & run.</div>
  </div>
  <div id="canvas-container"></div>
  <div id="credit">three.js r128 style demo</div>

  <script type="module">
    // imports (using three r128 module builds)
    import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    // DOM
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const container = document.getElementById('canvas-container');

    // Core vars
    let renderer, scene, camera, controls, animationId;
    let player, clock;
    let worldGroup; // group to hold world meshes (so we can reset easily)
    let isRunning = false;

    // Simple maze layout (1 = wall, 0 = floor)
    // A 9x9 layout (centered). You can edit to change walls.
    const maze = [
      [1,1,1,1,1,1,1,1,1],
      [1,0,0,0,1,0,0,0,1],
      [1,0,1,0,1,0,1,0,1],
      [1,0,1,0,0,0,1,0,1],
      [1,0,1,1,1,1,1,0,1],
      [1,0,0,0,0,0,0,0,1],
      [1,0,1,0,1,0,1,0,1],
      [1,0,0,0,1,0,0,0,1],
      [1,1,1,1,1,1,1,1,1],
    ];

    // Geometry/material caches
    const wallGeom = new THREE.BoxBufferGeometry(1, 2, 1);
    const floorGeom = new THREE.PlaneBufferGeometry(1,1);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x6b6b6b, roughness: 0.6, metalness: 0.05 });
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x222244, roughness: 0.9, metalness: 0.0 });

    // Initialize scene objects (call once when start pressed)
    function initScene() {
      // renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.innerHTML = ''; // clear
      container.appendChild(renderer.domElement);

      // scene + clock
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1020);
      clock = new THREE.Clock();

      // camera
      camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 200);
      camera.position.set(0, 6, 10);

      // controls for debugging / orbiting
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 1, 0);

      // lights
      const hemi = new THREE.HemisphereLight(0xddeeff, 0x080820, 0.6);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 5);
      dir.castShadow = true;
      dir.shadow.mapSize.set(2048, 2048);
      dir.shadow.camera.near = 0.5;
      dir.shadow.camera.far = 50;
      dir.shadow.camera.left = -15;
      dir.shadow.camera.right = 15;
      dir.shadow.camera.top = 15;
      dir.shadow.camera.bottom = -15;
      scene.add(dir);

      // world group
      worldGroup = new THREE.Group();
      scene.add(worldGroup);

      // build floor and maze
      buildMaze();

      // player (simple capsule: sphere on top of cylinder)
      player = new THREE.Group();
      const body = new THREE.Mesh(new THREE.SphereBufferGeometry(0.35, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff6b6b }));
      body.castShadow = true;
      body.position.y = 0.6;
      player.add(body);
      player.position.set(1.5, 0, 1.5); // starting tile (changeable)
      scene.add(player);

      // camera follow offset (we'll update camera each frame)
      camera.position.set(player.position.x, player.position.y + 4.2, player.position.z + 6);
      controls.target.copy(player.position);

      // listen for resize
      window.addEventListener('resize', onWindowResize);
    }

    // Build maze from 'maze' array
    function buildMaze() {
      const size = maze.length;
      const half = size / 2;
      // Ground plane (big)
      const ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(size * 1.2, size * 1.2), new THREE.MeshStandardMaterial({ color: 0x1e1f2f, roughness: 1 }));
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -0.001;
      ground.receiveShadow = true;
      worldGroup.add(ground);

      // tiles/walls
      for (let z = 0; z < size; z++) {
        for (let x = 0; x < size; x++) {
          const tile = maze[z][x];
          // compute centered coords: each tile is 1x1
          const px = (x - half) + 0.5;
          const pz = (z - half) + 0.5;

          // optional floor tile (subtle)
          const floor = new THREE.Mesh(floorGeom, floorMat);
          floor.rotation.x = -Math.PI/2;
          floor.position.set(px, 0, pz);
          floor.receiveShadow = true;
          worldGroup.add(floor);

          if (tile === 1) {
            const wall = new THREE.Mesh(wallGeom, wallMat);
            wall.position.set(px, 1.0, pz); // height 2, so center at y=1
            wall.castShadow = true;
            wall.receiveShadow = true;
            worldGroup.add(wall);
          }
        }
      }
    }

    // Start animation/render loop
    function animate() {
      if (!isRunning) return; // safety guard
      const dt = clock.getDelta();

      // simple player bobbing for life
      const t = clock.getElapsedTime();
      player.position.y = Math.sin(t * 2) * 0.03; // tiny bob

      // update camera to follow the player smoothly
      const desiredCamPos = new THREE.Vector3(player.position.x, player.position.y + 4.2, player.position.z + 6);
      camera.position.lerp(desiredCamPos, Math.min(1, dt * 3));
      controls.target.lerp(player.position.clone().setY(player.position.y + 0.6), Math.min(1, dt * 6));
      controls.update();

      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    }

    // Stop + cleanup
    function stopAndCleanup() {
      isRunning = false;
      if (animationId) cancelAnimationFrame(animationId);
      window.removeEventListener('resize', onWindowResize);
      if (renderer) {
        renderer.dispose();
        // dispose materials/geometries we created
        wallGeom.dispose();
        floorGeom.dispose();
        renderer.domElement.remove();
      }
      // clear references
      renderer = scene = camera = controls = null;
    }

    // Window resize handler
    function onWindowResize() {
      if (!renderer || !camera) return;
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    // Public button handlers
    startBtn.addEventListener('click', () => {
      // Prevent double init
      if (isRunning) return;
      // Initialize and start
      initScene();
      isRunning = true;
      animate();
      startBtn.disabled = true;
      resetBtn.disabled = false;
      startBtn.textContent = 'Running...';
      document.getElementById('hint').innerHTML = 'Use mouse to orbit, scroll to zoom. Press <strong>Reset</strong> to restart the scene.';
    });

    resetBtn.addEventListener('click', () => {
      // full stop and re-init so everything starts fresh
      if (!isRunning) return;
      stopAndCleanup();
      // small delay to ensure disposal finished (not asynchronous work, but safe)
      // then allow restart
      startBtn.disabled = false;
      resetBtn.disabled = true;
      startBtn.textContent = 'Start Game';
      document.getElementById('hint').innerHTML = 'Click <strong>Start Game</strong> to initialize & run.';
    });

    // Helpful: start with a friendly resize to set canvas size if user opens without pressing start
    window.addEventListener('resize', () => {
      if (renderer) onWindowResize();
    });

    // (Optional) Keyboard controls for simple movement â€” light demo
    window.addEventListener('keydown', (e) => {
      if (!isRunning) return;
      const speed = 0.35;
      if (e.key === 'w' || e.key === 'ArrowUp') player.position.z -= speed;
      if (e.key === 's' || e.key === 'ArrowDown') player.position.z += speed;
      if (e.key === 'a' || e.key === 'ArrowLeft') player.position.x -= speed;
      if (e.key === 'd' || e.key === 'ArrowRight') player.position.x += speed;
    });

    // Provide fallback message if WebGL not available
    if (!window.WebGLRenderingContext) {
      startBtn.disabled = true;
      document.getElementById('hint').textContent = 'WebGL not supported by your browser.';
    }
  </script>
</body>
</html>
